<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

    <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Solving Schema Bloat with Postgresql’s JSONB | Middle Path Development - Blog</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Solving Schema Bloat with Postgresql’s JSONB" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Blog Home" />
<meta property="og:description" content="Blog Home" />
<link rel="canonical" href="http://localhost:4000/blog/solving-schema-bloat-with-jsonb.html" />
<meta property="og:url" content="http://localhost:4000/blog/solving-schema-bloat-with-jsonb.html" />
<meta property="og:site_name" content="Middle Path Development - Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-06T00:00:00-08:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/blog/solving-schema-bloat-with-jsonb.html","headline":"Solving Schema Bloat with Postgresql’s JSONB","dateModified":"2018-01-06T00:00:00-08:00","datePublished":"2018-01-06T00:00:00-08:00","description":"Blog Home","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/solving-schema-bloat-with-jsonb.html"},"@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="/assets/css/style.css?v=ec7982154cf5967b6cad70dd16ba2d14206e8e73">
    <link rel="stylesheet" type="text/css" href="/css/custom.css">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Solving Schema Bloat with Postgresql's JSONB</h1>
    </section>
    
    <section class="main-content">
      <div class="home-link-container">
  <a class="blog-home-link" href="/blog">Blog Home</a>
</div>

<p>I often find myself inheriting projects with database schema’s that suffer from <em>schema bloat</em>.  What is “schema bloat”, one might ask ?  Great question, since I just invented the term.  Here is my definition:</p>

<p>Schema Bloat:  The act of adding more and more non-essential columns to a database table in order solve problems for a limited group of your application’s users.</p>

<p>“Table Bloat” would probably make more sense, however, the term “table bloat” has a specific <a href="https://dba.stackexchange.com/questions/126258/what-is-table-bloating-in-databases" target="_blank">meaning</a>.  So we will stick with “schema bloat” for the remainder of this article.</p>

<h2 id="schema-bloat">Schema Bloat</h2>
<p>Typically there is a central table for an application - often <em>users</em> or <em>companies</em> or something similar.  The schema bloat problem typically happens when the following occurs:</p>

<ul>
  <li>Company A needs to track some data that only effects Company A.  To solve this, columns are added to various tables.</li>
  <li>Rinse and repeat for companies B, C, D ….</li>
</ul>

<p>It’s reasonable to ask, especially if inheriting an existing database, why bother refactoring this column-bloated schema ?  What do we gain ?</p>

<p>The initial costs of doing this refactoring (which adds zero new features) are significant.  We will cover the specifics later, but for now, let’s go with the assumption that this is not going to be a simple task.  Despite the scariness (and difficulty of selling this kind of refactoring), the gains are	 significant.</p>

<h4 id="by-getting-rid-of-these-non-essential-columns-we-gain">By getting rid of these non-essential columns, we gain:</h4>

<p><em>A clearer picture of the data-model</em>.  There is much room for error and confusion when working on abstract concepts like a DB schema.  Anything we can do to simplify and clarify how our data is organized will help programmers working on the app.  If we can see that one group of values only applies to Company A and another group to Company B, <strong>at the DB level</strong>, it makes our data much easier to understand.</p>

<p><em>Working with the data can be easier</em>.  I’ve inherited tables with 150+ columns.  Most of them non-essential.  How many hours do programs spend squinting at their screens trying to find the proper column name ?  The vast majority of the columns they need to scroll by might not even apply to the company/user that is needing attention.  And one can imagine how this problem can become exponentially more difficult if columns have obscure and similar sounding names:  <code class="highlighter-rouge">xprt_vs_cd_tps</code> or <code class="highlighter-rouge">xprt_vs_cd_rts</code> .  Like finding a needle in a haystack!</p>

<p><img src="http://foolishlego.com/wp-content/uploads/2014/10/lego_2_277.jpg" alt="Pic" /></p>

<p>This is a real cost to consider.   In addition, not addressing this kind of problem makes day to day life much more unpleasant for your programmers.  Worker happiness is important !</p>

<p><img src="https://uproxx.files.wordpress.com/2014/09/george-costanza.jpg?quality=100&amp;w=650&amp;h=400" alt="Pic" /></p>

<hr />

<h2 id="what-is-jsonb-">What is JSONB ?</h2>
<p>JSONB is a column type (data type) that is part of the wonderful Postgresql, open-source database.  Essentially we can store nested JSON (Javascript Object Notation) objects in this column.  <em>We are going to assume the reader is familiar with JSON.  If not, the internet is your friend</em>.  This column type gives Postgres the sort of key/value store that is associated with NoSQL databases.  JSONB also provides tools for indexing and querying these JSON objects which we shall cover presently.</p>

<h4 id="jsonb-basics">JSONB Basics</h4>

<p>Let’s briefly go over some of the basics ways to work with JSONB.  Adding a JSONB column is quite easy:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">companies</span> <span class="p">(</span>
  <span class="n">optional_data</span> <span class="n">jsonb</span>
<span class="p">);</span>
</code></pre></div></div>

<p>We also want to (usually) index these JSONB columns.  And we want to use a GIN index.  The reasons for this index are beyond the scope of this talk, as is the discussion about when and why to use indexes.  For the vast majority of situations, the GIN index will work nicely.  This index can also be placed on an individual attribute in the JSONB column.  Here we will apply it to the entire column.</p>

<p><code class="highlighter-rouge">CREATE INDEX optional_data_idx ON companies USING GIN (optional_data);</code></p>

<p>Once we have a JSONB column we can insert JSON objects into that column.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">companies</span><span class="p">(</span><span class="n">optional_data</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">'{"opt_att": "Some Val 1", "another_opt_att": "Another Val 1"}'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">companies</span><span class="p">(</span><span class="n">optional_data</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">'{"opt_att": "Some Val 2", "another_opt_att": "Another Val 2", "nested_obj": {"nested_att": "some nested value"}}'</span><span class="p">);</span>
</code></pre></div></div>

<p>The syntax for querying values from a JSONB column is fairly straightforward.  There are lots of JSONB functions and operators that we are not going to cover.  You can <a href="https://www.postgresql.org/docs/9.5/static/functions-json.html" target="_blank">read about them here</a>.</p>

<p>Use the <code class="highlighter-rouge">-&gt;&gt;</code> operator to select a value at the attribute level.   The following query:</p>

<p><code class="highlighter-rouge">SELECT optional_data-&gt;&gt;’opt_att’ FROM companies LIMIT 1;</code></p>

<p>Should return <code class="highlighter-rouge">Some Val 1</code>.</p>

<p>You can select nested values using a combination of the <code class="highlighter-rouge">-&gt;</code> and <code class="highlighter-rouge">-&gt;&gt;</code> operators.</p>

<p><code class="highlighter-rouge">SELECT optional_data-&gt;’nested_obj’-&gt;&gt;’nested_att’ FROM companies;</code></p>

<p>Should return <code class="highlighter-rouge">some nested value</code>.</p>

<h4 id="jsonb-solution-for-schema-bloat---the-big-idea">JSONB solution for Schema Bloat - The Big Idea</h4>

<p>Our big idea is actually quite simple.  We are going to move any column that is “optional” (not used by every company) into a JSONB column, thus slimming down our bloated table(s) significantly.  It’s a fairly simple idea at the DB level.</p>

<p>Once we get into the Ruby (or insert other language here) level things can become more complex.  We need to make sure our getters and setters are doing the correct thing. The thought of refactoring a lot of views in the application can be daunting enough to scare off would-be-refactorers.  Luckily for us (in the Ruby world and beyond), we have some tools that can help us handle this Ruby refactoring at a low level, and save us from having to change the view layer at all (in most cases).</p>

<hr />

<h2 id="ruby-and-the-storext-gem">Ruby and the Storext Gem</h2>
<p>Welcome to the Ruby part of this article!  The <a href="https://github.com/G5/storext" target="_blank">Storext</a> gem makes it easy for ActiveRecord to work with JSONB.  The Storext gem also wraps the Virtus gem, so let’s talk about that briefly.</p>

<h4 id="virtus-gem">Virtus Gem</h4>

<p>The Virtus gem assists in creating virtual attributes for a Ruby object.  In our case, it is an object that inherits from ActiveRecord::Base - a model.  When can think of <a href="https://github.com/solnic/virtus" target="_blank">Virtus</a> as a pumped up version of  <code class="highlighter-rouge">attr_accessor</code>.  The important part of Virtus is that it can enforce type restrictions, which helps a virtual attribute behave more like a column.  Ideally, we want Rails to see no difference between fetching data from a “normal” column, versus our JSONB, optional_values attribute.</p>

<h4 id="using-storext-with-rails">Using Storext with Rails</h4>

<p>Let’s jump into the nuts and bolts of how we accomplish this JSONB refactoring.  We’ll be working with the <code class="highlighter-rouge">Foobar</code> object - which is backed by a table with WAY too many optional columns (let’s use our imaginations).</p>

<p>We can store a hard-coded (or if you want to get really flexible, store this data in the DB instead) file in our <code class="highlighter-rouge">app/models/concerns</code> directory that has information about all of our custom attributes, for a given company.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Company1CustomAtts</span> 
  <span class="no">COMPANY1_CUSTOM_ATTS</span> <span class="o">=</span> <span class="p">[</span>
   <span class="p">{</span><span class="ss">:key</span><span class="o">=&gt;</span><span class="s2">"att_1"</span><span class="p">,</span> <span class="ss">:type</span><span class="o">=&gt;</span><span class="s2">"Boolean"</span><span class="p">,</span> <span class="ss">:default</span><span class="o">=&gt;</span><span class="kp">false</span><span class="p">},</span>
   <span class="p">{</span><span class="ss">:key</span><span class="o">=&gt;</span><span class="s2">"att_2"</span><span class="p">,</span> <span class="ss">:type</span><span class="o">=&gt;</span><span class="s2">"DateTime"</span><span class="p">},</span>
   <span class="p">{</span><span class="ss">:key</span><span class="o">=&gt;</span><span class="s2">"att_3"</span><span class="p">,</span> <span class="ss">:type</span><span class="o">=&gt;</span><span class="s2">"String"</span><span class="p">},</span>
   <span class="c1"># ...</span>
  <span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We’ve stored info about our custom attributes in a hash.  Now we just need to tell our model about these custom attributes.  Here is where Storext and Virtus make our lives much easier!</p>

<p>In Rails 4.2 and beyond, creating a JSONB column on a table is easy (if you are using an earlier version of Rails, some Ruby gems might help you or trying just writing the migration in raw SQL).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">create_table</span> <span class="ss">:foobars</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
  <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:company_id</span><span class="p">,</span>  <span class="ss">null: </span><span class="kp">false</span>
  <span class="n">t</span><span class="p">.</span><span class="nf">jsonb</span> <span class="ss">:optional_attributes</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">default: </span><span class="s1">'{}'</span>
<span class="k">end</span>
<span class="n">add_index</span> <span class="ss">:foobars</span><span class="p">,</span> <span class="ss">:optional_attributes</span><span class="p">,</span> <span class="ss">using: :gin</span>
</code></pre></div></div>

<p>And our model code will look something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foobar</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="kp">include</span> <span class="no">Company1CustomAtts</span>
  <span class="kp">include</span> <span class="no">Company2CustomAtts</span>
  <span class="kp">include</span> <span class="no">Storext</span><span class="p">.</span><span class="nf">model</span>
  <span class="vc">@@all_custom_atts</span> <span class="o">=</span> <span class="no">COMPANY1_CUSTOM_ATTS</span> <span class="o">+</span> <span class="no">COMPANY2_CUSTOM_ATTS</span>
  <span class="vc">@@all_custom_atts</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">hash</span><span class="o">|</span>
    <span class="n">store_attribute</span> <span class="ss">:optional_attributes</span><span class="p">,</span> <span class="nb">hash</span><span class="p">[</span><span class="ss">:key</span><span class="p">].</span><span class="nf">to_sym</span><span class="p">,</span> <span class="nb">hash</span><span class="p">[</span><span class="ss">:type</span><span class="p">],</span> <span class="ss">default: </span><span class="nb">hash</span><span class="p">[</span><span class="ss">:default</span><span class="p">]</span>
  <span class="k">end</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>We need to include our collection of custom attributes.  We also need to include the <code class="highlighter-rouge">Storext.model</code> module to get the Storext functionality for our Foobar model.  Once that is done, we can cycle through our collection of attributes and pass them to the <code class="highlighter-rouge">store_attribute</code> method.   We pass some other metadata along about the attributes (type and default values).  The <code class="highlighter-rouge">store_attribute</code> method, sets up setters and getters for each JSONB attribute we have in our collection.  After we execute this code, we can do things like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foobar</span> <span class="o">=</span> <span class="no">Foobar</span><span class="p">.</span><span class="nf">first</span>
<span class="n">foobar</span><span class="p">.</span><span class="nf">att_1</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">foobar</span><span class="p">.</span><span class="nf">save</span>
<span class="n">new_var</span> <span class="o">=</span> <span class="no">Foobar</span><span class="p">.</span><span class="nf">first</span>
<span class="n">new_var</span><span class="p">.</span><span class="nf">att_1</span> <span class="c1"># returns 42</span>
</code></pre></div></div>

<p>and Rails will fetch the value from the JSONB attribute, just as if it was a regular database column.</p>

<p>The amazing win here (DO NOT forget to read the “Gotchas” section below) is that once we have this set up, Rails is not even aware that the values are coming from JSONB.  Our getters and setters are magically working!  And things like <code class="highlighter-rouge">form_for</code>  <em>just work</em> (so far to my knowledge - I’m sure there are edge-cases).</p>

<p>Once we realized that we did not have to refactor our views, forms etc… this refactoring became a lot more attractive.  It seems we can solve this at the Ruby level with only a few lines of code!</p>

<h4 id="gotchas---jsonb-and-rails">Gotchas - JSONB and Rails</h4>

<p>There are definitely some columns that even if optional, may not be good candidates for our JSONB refactoring.   Let’s examine a few cases.</p>

<p><em>Foreign Keys</em>.  ActiveRecord expects foreign keys to be legitimate database columns.  I’m sure one could get this to work using some of the macros provided by ActiveRecord or even diving down to a low level in ActiveRecord.  I would not recommend it.  I think schema bloat is usually not caused by excessive foreign keys.  If that is a problem with a database table, I suspect there are deeper schema problems to address.</p>

<p><em>Low level database queries</em>.  Although we are working with Rails, there often comes a time when we need to drop down to the SQL level and write our query.  Maybe we need to run a Postgresql function.  Maybe we just need to access an attribute outside of ActiveRecord.  Obviously, if you’ve written raw SQL, you will need to refactor it to use the JSONB syntax.  This is not so much a “gotcha” as a friendly reminder.</p>

<p><em>Data migration (over to JSONB) can be tricky</em>.  If we are inheriting a bloated schema, we will need to migrate that data over to it’s new JSONB home.  Once we write the Storext code, the model will start using those getters/setters because they are defined last in the model.  When a Rails model inherits from ActiveRecord it automagically inherits setters and getters for each database column.  That is defined in line 1 of our model (<code class="highlighter-rouge">class Foobar &lt; ActiveRecord::Base</code>).  Since the Storext code runs after line 1, those getters and setters over-write the ActiveRecord getters and setters.  One way to help get around the trickiness this code introduces is by remembering the following:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foobar</span> <span class="o">=</span> <span class="no">Foobar</span><span class="p">.</span><span class="nf">new</span>
<span class="n">foobar</span><span class="p">.</span><span class="nf">att_1</span> <span class="c1"># uses the ruby getter for "att_1" (in our case the JSONB attribute) to fetch the value</span>
<span class="n">foobar</span><span class="p">[</span><span class="s1">'att_1'</span><span class="p">]</span> <span class="c1"># uses the foobars.att_1 database column to fetch the value</span>
</code></pre></div></div>
<p>For more complex data migrations, doing things at a lower level in ActiveRecord or at the SQL level might be required.  Once the migration is complete, it is possible to delete or hide (rename) the legacy columns.</p>

<p><em>Optional columns that require lots of aggregate data calculations</em>.  It is possible that one may face performance issues if there needs to be lots of aggregate functions / calculations run on the JSONB attributes.  This is definitely beyond the scope of this article, but I think it’s safe to say that this issue probably only effects those that have large data sets.  Large enough that we need to start thinking about scale.   This last gotcha probably does not apply to most web applications.</p>

<hr />

<h2 id="solving-schema-bloat-outside-of-jsonb">Solving Schema Bloat Outside of JSONB</h2>
<p>Even without JSONB, we can handle non-essential, optional attributes without adding a bunch of columns to a bloated table.  It requires more moving parts and can perform worse (lots of JOINS needed), but let’s take a look at that schema pattern.</p>

<p>We can set up on table to store our attribute names and a second table to store the related values, scoped to each Foobar object.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>optional_attributes
-----------------+------------------------+
 id              | integer                |
 company_id      | integer                |
 attribute_name  | character varying(255) |
-----------------+------------------------+
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foobar_optional_attributes
--------------------------+------------------------+
 id                       | integer                |
 foobar_id                | integer                |
 optional_attribute_id    | integer                |
 optional_attribute_value | character varying(255) |
--------------------------+------------------------+
</code></pre></div></div>

<p>We choose the simple example because it illustrates our point clearly.  We can add as many rows as needed to cover the optional attributes.  We no longer need these optional attributes as database columns.  Therefore, schema bloat can be solved without JSONB, however, JSONB makes it much easier.  The example above is only meant to illustrate a schema pattern/idea.  I’m not suggesting it as a viable solution for most applications.</p>

<h2 id="summary">Summary</h2>
<p>Discovering how to easily use Postgresql’s JSONB to manage optional data can really help slim down some bloated tables.  So if you have a bloated schema,  and you are in the Postgresql world, consider JSONB to solve schema bloat!</p>

<div class="home-link-container">
  <a class="blog-home-link" href="/blog">Blog Home</a>
</div>


      <footer class="site-footer">
  <div class="contact-link-collection-container">
    <div class="contact-link-container">
      <a class="contact_link" href="https://linkedin.com/in/benwanicur" target="_blank">
        <i class="fa fa-linkedin fa-2x"></i>
      </a>
    </div>
    <div class="contact-link-container">
      <a class="contact_link" href="https://github.com/bwanicur" target="_blank">
        <i class="fa fa-github fa-2x"></i>
      </a>
    </div>
  </div>
  <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
</footer>

    </section>

  </body>
</html>
